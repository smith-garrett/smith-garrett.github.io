<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>Parsing a simple formal language using F#</title> <header> <div class=blog-name ><a href="/">Garrett Smith</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/publications/">Publications</a> <li><a href="/posts/">Posts</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=parsing_a_simple_formal_language_using_f ><a href="#parsing_a_simple_formal_language_using_f" class=header-anchor >Parsing a simple formal language using F#</a></h1> <p>There is a field of study at the intersection of linguistics, mathematics, and computer science dedicated to characterization of sets of finite strings: formal language theory. A formal language is just a set containing strings drawn from some alphabet. For example, the set <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub><mo>=</mo><mo stretchy=false >{</mo><mi>a</mi><mo separator=true >,</mo><mi>b</mi><mo separator=true >,</mo><mi>c</mi><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">L_0 = \{a, b, c\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">L</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal">a</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class=mclose >}</span></span></span></span> is the formal language consisting of the strings &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; and nothing else. The three letters &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; make up the alphabet.</p> <p>In this post, I will concentrate on the language <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy=false >{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">L = \{a^n b^n\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class=mord ><span class="mord mathnormal">a</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal">b</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class=mclose >}</span></span></span></span>: the set of all strings containing <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \geq 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >≥</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >1</span></span></span></span> &quot;a&quot;s follows b <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> &quot;b&quot;s. This language belongs to the class of <a href="https://en.wikipedia.org/wiki/Context-free_language">context-free languages</a>. There&#39;s a lot of interesting things to discuss with context-free languages and formal language theory, especially with regard to how natural &#40;human&#41; languages relate to formal languages &#40;see <em>Mathematical Methods in Linguistics</em> by Partee, ter Meulen, and Wall, 1990 for a really good introduction&#41;. But today, I just want to implement a simple parser &#40;pushdown automaton&#41; for language <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> using the F# programming language.</p> <p>The parser will work like this: It scans the string one letter at a time. If it encounters an &quot;a&quot;, it adds 1 to its counter. &#40;Because there are only two accepted symbols in the alphabet, &quot;a&quot;, and &quot;b&quot;, we actually only need to track the depth of the stack and not its contents&#41;. When it encounters a &quot;b&quot;, it decreases its counter by 1. All other symbols in the input are ignored.</p> <p>To implement this in F#, we start by defining a stack record type, a data structure that just contains a named element for the stack depth:</p> <pre><code class="fsharp hljs"><span class=hljs-keyword >type</span> <span class="hljs-title class_">Stack</span> <span class=hljs-operator >=</span> {
    depth<span class=hljs-operator >:</span> <span class=hljs-type >int</span>
}</code></pre> <p>The parser is written as a simple command line program that takes a string as input. In order separate the string into characters and remove any characters that aren&#39;t &quot;a&quot; or &quot;b&quot;, I use the following function:</p> <pre><code class="fsharp hljs"><span class=hljs-keyword >let</span> sepInput (input<span class=hljs-operator >:</span> <span class=hljs-type >string</span>) <span class=hljs-operator >=</span>
    input.ToCharArray()
    <span class=hljs-operator >|&gt;</span> Array.toList
    <span class=hljs-operator >|&gt;</span> List.filter (<span class=hljs-keyword >fun</span> x <span class=hljs-operator >-&gt;</span> x <span class=hljs-operator >=</span> <span class=hljs-string >&#x27;a&#x27;</span> <span class=hljs-operator >||</span> x <span class=hljs-operator >=</span> <span class=hljs-string >&#x27;b&#x27;</span>)</code></pre> <p>Now comes the main function to actually process the input and determine whether it belongs the language <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>.</p> <pre><code class="fsharp hljs"><span class=hljs-keyword >let</span> parse (input<span class=hljs-operator >:</span> <span class=hljs-type >string</span>) <span class=hljs-operator >=</span>
    <span class=hljs-keyword >let</span> ipt <span class=hljs-operator >=</span> sepInput input

    <span class=hljs-comment >// Inner recursive function that works its way through the input</span>
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >rec</span> innerparse lst stck <span class=hljs-operator >=</span>
        <span class=hljs-keyword >match</span> lst <span class=hljs-keyword >with</span>
        <span class=hljs-operator >|</span> [] <span class=hljs-operator >-&gt;</span> stck
        <span class=hljs-operator >|</span> head <span class=hljs-operator >::</span> rest <span class=hljs-keyword >when</span> head <span class=hljs-operator >=</span> <span class=hljs-string >&#x27;a&#x27;</span> <span class=hljs-operator >-&gt;</span> innerparse <span class=hljs-keyword >rest</span> {stck <span class=hljs-keyword >with</span> depth <span class=hljs-operator >=</span> stck.depth <span class=hljs-operator >+</span> <span class=hljs-number >1</span>}
        <span class=hljs-operator >|</span> head <span class=hljs-operator >::</span> rest <span class=hljs-keyword >when</span> head <span class=hljs-operator >=</span> <span class=hljs-string >&#x27;b&#x27;</span> <span class=hljs-operator >-&gt;</span> innerparse <span class=hljs-keyword >rest</span> {stck <span class=hljs-keyword >with</span> depth <span class=hljs-operator >=</span> stck.depth <span class=hljs-operator >-</span> <span class=hljs-number >1</span>}
        <span class=hljs-comment >// Should never get here, but needed for completeness of pattern match</span>
        <span class=hljs-operator >|</span> head <span class=hljs-operator >::</span> rest <span class=hljs-operator >-&gt;</span> innerparse rest stck
    
    <span class=hljs-keyword >let</span> stack <span class=hljs-operator >=</span> innerparse <span class=hljs-keyword >ipt</span> {depth <span class=hljs-operator >=</span> <span class=hljs-number >0</span>}

    <span class=hljs-keyword >match</span> stack.depth <span class=hljs-keyword >with</span>
    <span class=hljs-operator >|</span> <span class=hljs-number >0</span> <span class=hljs-operator >-&gt;</span> <span class=hljs-literal >true</span>
    <span class=hljs-operator >|</span> _ <span class=hljs-operator >-&gt;</span> <span class=hljs-literal >false</span></code></pre> <p>After this, we just need the main program function to get the string argument and tell us if it belongs to <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>:</p> <pre><code class="fsharp hljs"><span class=hljs-meta >[&lt;EntryPoint&gt;]</span>
<span class=hljs-keyword >let</span> main args <span class=hljs-operator >=</span>
    <span class=hljs-keyword >let</span> result <span class=hljs-operator >=</span> parse args[<span class=hljs-number >0</span>]
    <span class=hljs-keyword >match</span> result <span class=hljs-keyword >with</span>
    <span class=hljs-operator >|</span> <span class=hljs-literal >true</span> <span class=hljs-operator >-&gt;</span> <span class=hljs-built_in >printf</span> <span class=hljs-string >&quot;String belongs to a^n b^n\n&quot;</span>
    <span class=hljs-operator >|</span> _ <span class=hljs-operator >-&gt;</span> <span class=hljs-built_in >printf</span> <span class=hljs-string >&quot;String doesn&#x27;t belong to a^n b^n\n&quot;</span>
    <span class=hljs-number >0</span></code></pre> <p>It would be nicer to handle the input to the program using, e.g., <a href="https://github.com/fsprojects/Argu">Argu</a>, but I&#39;ll leave that to another time.</p> <p>If we compile all this and run it with the string &quot;aaabb&quot;, we see that the string doesn&#39;t belong to <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>, but if we run it with &quot;aaabbb&quot;, we see that it does.</p> <p>The full code for this little project is available on <a href="https://github.com/smith-garrett/anbnparser">Github</a></p> <p>This post was an exercise in implementing a symbolic parser for a simple context-free language. It&#39;s interesting to note that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy=false >{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">L = \{a^n b^n\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class=mord ><span class="mord mathnormal">a</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal">b</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class=mclose >}</span></span></span></span> can also be exactly parsed using <a href="https://doi.org/10.1111/1468-0394.00126">fractal grammars</a> implemented as simple neural networks.</p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Garrett Smith. Last modified: July 31, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>